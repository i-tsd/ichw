## 计算概论作业2（2019/9/17）  
#### 1.图灵为什么要证明停机问题？其证明方法和数学原理是什么？  
停机问题是为了解决可计算性问题。换言之，停机问题证明了图灵机并非万能的，能解决的问题存在边界。证明过程主要采用了反证法的数学原理。  
证明方法大致可描述如下：图灵机以字符串的形式定义，故图灵机可以将自身或其他图灵机作为输入。 若图灵机万能，则可定义一图灵机 *__A__* ，其可判断任意图灵机 *__M__* 在输入 *P* 时是否可停机。若 *__M__* 在输入 *P* 时可停机，则 *__A__* 输出 yes ，反之则输出 no。  
现定义一图灵机 *__Q__* ，其定义如下：  
 
* 输入图灵机  *__M__*  并利用图灵机 *__A__* 判断 *__M__* 在输入为 *__M__* 自身时是否会停机。  
  * 若 *__A__* 输出 yes ，则 *__Q__* 进入死循环； 
  * 若 *__A__* 输出 no ，则 *__Q__* 停机。 
 
现在将输入为 *__Q__* 的图灵机 *__Q__* 作为图灵机 *__A__* 的输入。若 *__A__* 输出为 yes ，则 *__Q__* 在输入为 *__Q__* 时停机，但根据 *__Q__* 的定义，*__Q__* 在输入为 *__Q__* 时进入死循环方能使 *__A__* 输出 yes ，产生矛盾；  
若 *__A__* 输出为 no，则同理亦产生矛盾。  
该矛盾证明不可能存在这样的图灵机 *__A__* ，因而证实了图灵机可解决问题的范围是有限的。


#### 2.向中学生解释二进制补码的原理。
中学信息课中我们便接触过二进制和字、字节的概念。例如利用一个4个字的空间来存储一个二进制数，其可以存储的数从0000到1111，也就是十进制中的0到15。然而其中并不包含这个数字的符号信息，我们需要更多的信息来定义这个数字的符号。这便产生了存储与运算带符号整数，亦即包括负数在内的整数的问题。  
早期人们曾提出一些带符号存储数字的方法，其中比较有代表性的包括原码法和反码法。  
所谓源码便是用二进制四位码中的第一个字来表示符号，0表示正，1表示负；例如，0111表示数字+7，1110表示数字-6。而反码则是将二进制数的每一位取反（例如。由0变为1）来表示其相反数。例如，0111表示数字+7，则1000表示数字-7。显然在这两种编码方式中，最高位的数字表示了这个数的符号。  
这两种方法存在很多问题，例如不便直接进行运算（例如，将原码1001和0001相加并不会得到0000，这与我们1+(-1)=0的数学直觉背道而驰）、有两种表示方式不同的0等等。  
补码便是为了解决上述问题而被提出的。在补码中，若一个数用N个字节进行存储，求数 -n 的补码, 便是求一个二进制数(n')，使得(n + n' = 2^N)。读者可以自行验证，在补码中进行正负数的相加，只需进行包括符号位在内的补码相加并舍去最高位的进位，便可得到正确的运算结果。因此，补码是目前主流的存储带符号整数方法。

#### 3.某基于 IEEE 754浮点数格式的 16 bit 浮点数表示，有 8 个小数位，请给出 ±0, ±1.0, 最大非规范化数，最小非规范化数，最小规范化浮点数，最大规范化浮点数，±∞，NaN的二进制表示（表示形式请参照讲义）。

符号 | 指数 | 尾数 | 值
:-: | :-: | :-: | :-:
\* | 0000000 | 00000000 | ±0
\* | 0111111| 00000000 | ±1.0
\* | 0000000| 11111111 | ±(1-2^8)*2^-62
\* | 0000000| 00000000 | ±(2^8)*2^-62
\* | 0000001| 00000000 | ±2^-62
\* | 1111110| 11111111 | ±(2-2^8)*2^63
\* | 1111111| 00000000 | ±∞
\* | 1111111| 非0 | NaN
